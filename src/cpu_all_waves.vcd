$date
	Mon Dec  7 20:07:19 2020
$end
$version
	Icarus Verilog
$end
$timescale
	10ps
$end
$scope module mips_tb $end
$var wire 1 ! waitrequest $end
$var wire 32 " writedata [31:0] $end
$var wire 1 # write $end
$var wire 32 $ register_v0 [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 1 & read $end
$var wire 4 ' byte_en [3:0] $end
$var wire 32 ( address [31:0] $end
$var wire 1 ) active $end
$var reg 1 * clk $end
$var reg 1 + rst $end
$scope module cpuInst $end
$var wire 1 * clk $end
$var wire 32 , constant_1 [31:0] $end
$var wire 32 - constant_31 [31:0] $end
$var wire 32 . constant_4 [31:0] $end
$var wire 32 / constant_reset [31:0] $end
$var wire 1 + reset $end
$var wire 1 ! waitrequest $end
$var wire 1 # write $end
$var wire 4 0 state [3:0] $end
$var wire 32 1 signimm [31:0] $end
$var wire 32 2 shiftimm [31:0] $end
$var wire 1 3 reset_mux_cnt $end
$var wire 32 4 register_v0 [31:0] $end
$var wire 32 5 regbout [31:0] $end
$var wire 32 6 regaout [31:0] $end
$var wire 32 7 readdata [31:0] $end
$var wire 1 & read $end
$var wire 1 8 pc_write $end
$var wire 2 9 pc_src_mux [1:0] $end
$var wire 32 : pc_out [31:0] $end
$var wire 32 ; pc_data [31:0] $end
$var wire 32 < pc4_jump2 [31:0] $end
$var wire 3 = msk_cnt [2:0] $end
$var wire 32 > masked_data [31:0] $end
$var wire 1 ? lrmuxMSB $end
$var wire 1 @ lr_en $end
$var wire 1 A link_in $end
$var wire 1 B link_en $end
$var wire 1 C link $end
$var wire 1 D jump $end
$var wire 32 E irout [31:0] $end
$var wire 1 F ir_write $end
$var wire 1 G hilowrite $end
$var wire 1 H hilosel $end
$var wire 32 I hiloout [31:0] $end
$var wire 1 J halt $end
$var wire 32 K final_pc_data [31:0] $end
$var wire 32 L final_data [31:0] $end
$var wire 2 M extendcont [1:0] $end
$var wire 32 N constant_0 [31:0] $end
$var wire 2 O cond [1:0] $end
$var wire 2 P byte_cnt [1:0] $end
$var wire 4 Q byte_EN [3:0] $end
$var wire 32 R bout [31:0] $end
$var wire 32 S aout [31:0] $end
$var wire 32 T aluresult [31:0] $end
$var wire 4 U aluop [3:0] $end
$var wire 2 V alu2out [1:0] $end
$var wire 32 W altpcsrc [31:0] $end
$var wire 1 X altpcmux_cnt $end
$var wire 32 Y altpcdata [31:0] $end
$var wire 1 Z alt_pc_write $end
$var wire 32 [ address [31:0] $end
$var wire 1 ) active $end
$var wire 32 \ WriteRegData [31:0] $end
$var wire 32 ] SrcBOut [31:0] $end
$var wire 32 ^ SrcAOut [31:0] $end
$var wire 1 _ RegWrite $end
$var wire 2 ` RegDst [1:0] $end
$var wire 2 a MemToReg [1:0] $end
$var wire 1 b Jump_EN $end
$var wire 1 c JumpIN $end
$var wire 2 d IorD_cnt [1:0] $end
$var wire 5 e Dst [4:0] $end
$var wire 3 f ALUSrcB [2:0] $end
$var wire 2 g ALUSrcA [1:0] $end
$var wire 1 h ABswitch_cnt $end
$var reg 32 i aluout [31:0] $end
$var reg 1 j branch $end
$var reg 4 k byteenable [3:0] $end
$var reg 2 l lrmuxLSB [1:0] $end
$var reg 4 m prev_state [3:0] $end
$var reg 32 n writedata [31:0] $end
$scope module IorD_mux $end
$var wire 32 o b [31:0] $end
$var wire 32 p c [31:0] $end
$var wire 2 q select [1:0] $end
$var wire 32 r d [31:0] $end
$var wire 32 s a [31:0] $end
$var reg 32 t out [31:0] $end
$upscope $end
$scope module MemToReg_mux $end
$var wire 32 u a [31:0] $end
$var wire 32 v c [31:0] $end
$var wire 2 w select [1:0] $end
$var wire 32 x d [31:0] $end
$var wire 32 y b [31:0] $end
$var reg 32 z out [31:0] $end
$upscope $end
$scope module RegDst_mux $end
$var wire 5 { a [4:0] $end
$var wire 5 | b [4:0] $end
$var wire 5 } c [4:0] $end
$var wire 5 ~ d [4:0] $end
$var wire 2 !" select [1:0] $end
$var reg 5 "" out [4:0] $end
$upscope $end
$scope module Registers $end
$var wire 1 * clk $end
$var wire 5 #" rr1 [4:0] $end
$var wire 5 $" rr2 [4:0] $end
$var wire 1 + rst $end
$var wire 32 %" wd [31:0] $end
$var wire 5 &" wr [4:0] $end
$var wire 1 _ wren $end
$var reg 1 '" a $end
$var reg 1 (" b $end
$var reg 32 )" r0 [31:0] $end
$var reg 1024 *" registers [1023:0] $end
$var reg 32 +" rs [31:0] $end
$var reg 32 ," rt [31:0] $end
$var reg 32 -" v0 [31:0] $end
$upscope $end
$scope module alt_pc $end
$var wire 1 * clk $end
$var wire 1 + rst $end
$var wire 1 Z wr_en $end
$var wire 32 ." p [31:0] $end
$var reg 32 /" q [31:0] $end
$var reg 32 0" single_reg [31:0] $end
$upscope $end
$scope module altpcmux $end
$var wire 32 1" a [31:0] $end
$var wire 1 X select $end
$var wire 32 2" b [31:0] $end
$var reg 32 3" out [31:0] $end
$upscope $end
$scope module alu $end
$var wire 4 4" ctrl [3:0] $end
$var wire 32 5" b [31:0] $end
$var wire 32 6" a [31:0] $end
$var reg 2 7" comp [1:0] $end
$var reg 32 8" out [31:0] $end
$upscope $end
$scope module alu2 $end
$var wire 1 * clk $end
$var wire 2 9" p [1:0] $end
$var wire 1 + rst $end
$var reg 2 :" q [1:0] $end
$var reg 2 ;" single_reg [1:0] $end
$upscope $end
$scope module brancher $end
$var wire 2 <" cond [1:0] $end
$var wire 6 =" fn [5:0] $end
$var wire 5 >" info [4:0] $end
$var wire 6 ?" opcode [5:0] $end
$var wire 4 @" state [3:0] $end
$var reg 1 c JumpIN $end
$var reg 1 b Jump_EN $end
$upscope $end
$scope module byte_a $end
$var wire 2 A" aluout [1:0] $end
$var wire 2 B" byte_cnt [1:0] $end
$var reg 4 C" byte_en [3:0] $end
$upscope $end
$scope module const_register $end
$var wire 32 D" const_1 [31:0] $end
$var wire 32 E" const_31 [31:0] $end
$var wire 32 F" const_4 [31:0] $end
$var wire 32 G" reset_vector [31:0] $end
$upscope $end
$scope module decoder_a $end
$var wire 1 j branch $end
$var wire 1 * clk $end
$var wire 6 H" ir_function [5:0] $end
$var wire 5 I" ir_info [4:0] $end
$var wire 6 J" ir_opcode [5:0] $end
$var wire 6 K" mem_function [5:0] $end
$var wire 5 L" mem_info [4:0] $end
$var wire 6 M" mem_opcode [5:0] $end
$var wire 1 ! wait_request $end
$var wire 4 N" state [3:0] $end
$var wire 1 C link $end
$var reg 1 h ABswitch_cnt $end
$var reg 2 O" ALUSrcA [1:0] $end
$var reg 3 P" ALUSrcB [2:0] $end
$var reg 2 Q" IorD [1:0] $end
$var reg 1 F IrWrite $end
$var reg 1 & MemRead $end
$var reg 2 R" MemToReg [1:0] $end
$var reg 1 # MemWrite $end
$var reg 2 S" PCSrc [1:0] $end
$var reg 1 8 PcWrite $end
$var reg 2 T" RegDst [1:0] $end
$var reg 1 _ RegWrite $end
$var reg 1 U" addiu $end
$var reg 1 V" addu $end
$var reg 1 Z altpcWrite $end
$var reg 1 X altpcmux $end
$var reg 4 W" aluop [3:0] $end
$var reg 1 X" andINT $end
$var reg 1 Y" andi $end
$var reg 1 Z" beq $end
$var reg 1 [" bgez $end
$var reg 1 \" bgezal $end
$var reg 1 ]" bgtz $end
$var reg 1 ^" blez $end
$var reg 1 _" bltz $end
$var reg 1 `" bltzal $end
$var reg 1 a" bne $end
$var reg 2 b" byte_cnt [1:0] $end
$var reg 1 c" div $end
$var reg 1 d" divu $end
$var reg 2 e" extendcont [1:0] $end
$var reg 1 H hilosel $end
$var reg 1 G hilowrite $end
$var reg 1 f" j $end
$var reg 1 g" jal $end
$var reg 1 h" jalr $end
$var reg 1 i" jr $end
$var reg 1 j" lb $end
$var reg 1 k" lbu $end
$var reg 1 l" lh $end
$var reg 1 m" lhu $end
$var reg 1 B link_en $end
$var reg 1 A link_in $end
$var reg 1 @ lr_en $end
$var reg 1 ? lrmux $end
$var reg 1 n" lui $end
$var reg 1 o" lw $end
$var reg 1 p" lwl $end
$var reg 1 q" lwr $end
$var reg 3 r" mask_cnt [2:0] $end
$var reg 1 s" mfhi $end
$var reg 1 t" mflo $end
$var reg 1 u" mthi $end
$var reg 1 v" mtlo $end
$var reg 1 w" mult $end
$var reg 1 x" multu $end
$var reg 1 y" nop $end
$var reg 1 z" orINT $end
$var reg 1 {" ori $end
$var reg 1 3 resetmux $end
$var reg 1 |" sb $end
$var reg 1 }" sh $end
$var reg 1 ~" sll $end
$var reg 1 !# sllv $end
$var reg 1 "# slt $end
$var reg 1 ## slti $end
$var reg 1 $# sltiu $end
$var reg 1 %# sltu $end
$var reg 1 &# sra $end
$var reg 1 '# srav $end
$var reg 1 (# srl $end
$var reg 1 )# srlv $end
$var reg 1 *# subu $end
$var reg 1 +# sw $end
$var reg 1 ,# xorINT $end
$var reg 1 -# xori $end
$upscope $end
$scope module extender $end
$var wire 16 .# in [15:0] $end
$var wire 2 /# select [1:0] $end
$var reg 32 0# out [31:0] $end
$upscope $end
$scope module halter_a $end
$var wire 1 * clk $end
$var wire 1 + rst $end
$var wire 4 1# state [3:0] $end
$var wire 32 2# pcout [31:0] $end
$var reg 1 J halt $end
$upscope $end
$scope module hiloreg_a $end
$var wire 1 G WrEn $end
$var wire 1 * clk $end
$var wire 1 H ctrl_hi $end
$var wire 32 3# input_hi_lo [31:0] $end
$var wire 1 + reset $end
$var reg 32 4# out [31:0] $end
$var reg 32 5# reg_hi [31:0] $end
$var reg 32 6# reg_lo [31:0] $end
$upscope $end
$scope module ir $end
$var wire 1 * clk $end
$var wire 1 + rst $end
$var wire 1 F wr_en $end
$var wire 32 7# p [31:0] $end
$var reg 32 8# q [31:0] $end
$var reg 32 9# single_reg [31:0] $end
$upscope $end
$scope module jump_reg $end
$var wire 1 * clk $end
$var wire 1 c p $end
$var wire 1 + rst $end
$var wire 1 b wr_en $end
$var reg 1 D q $end
$var reg 1 :# single_reg $end
$upscope $end
$scope module jumpshifter $end
$var wire 32 ;# irout [31:0] $end
$var wire 32 <# pcout [31:0] $end
$var reg 4 =# half1 [3:0] $end
$var reg 26 ># half2 [25:0] $end
$var reg 32 ?# pc4jump2 [31:0] $end
$upscope $end
$scope module link_reg $end
$var wire 1 * clk $end
$var wire 1 A p $end
$var wire 1 + rst $end
$var wire 1 B wr_en $end
$var reg 1 C q $end
$var reg 1 @# single_reg $end
$upscope $end
$scope module loadword_mask $end
$var wire 3 A# msk_cnt [2:0] $end
$var wire 2 B# msk_cnt2 [1:0] $end
$var wire 32 C# data [31:0] $end
$var reg 32 D# masked_data [31:0] $end
$var reg 32 E# temp1 [31:0] $end
$var reg 32 F# temp2 [31:0] $end
$upscope $end
$scope module lrblock_a $end
$var wire 32 G# final_data [31:0] $end
$var wire 1 @ lr_en $end
$var wire 3 H# lrmux [2:0] $end
$var wire 32 I# masked_data [31:0] $end
$var wire 32 J# bout [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 * clk $end
$var wire 1 + rst $end
$var wire 1 8 wr_en $end
$var wire 32 K# p [31:0] $end
$var reg 32 L# q [31:0] $end
$var reg 32 M# single_reg [31:0] $end
$upscope $end
$scope module pcsrc_mux $end
$var wire 32 N# a [31:0] $end
$var wire 32 O# b [31:0] $end
$var wire 32 P# c [31:0] $end
$var wire 32 Q# d [31:0] $end
$var wire 2 R# select [1:0] $end
$var reg 32 S# out [31:0] $end
$upscope $end
$scope module resetmux $end
$var wire 32 T# a [31:0] $end
$var wire 32 U# b [31:0] $end
$var wire 1 3 select $end
$var reg 32 V# out [31:0] $end
$upscope $end
$scope module shifter2 $end
$var wire 32 W# in [31:0] $end
$var reg 32 X# out [31:0] $end
$upscope $end
$scope module srcamux $end
$var wire 32 Y# a [31:0] $end
$var wire 32 Z# c [31:0] $end
$var wire 32 [# d [31:0] $end
$var wire 2 \# select [1:0] $end
$var wire 32 ]# b [31:0] $end
$var reg 32 ^# out [31:0] $end
$upscope $end
$scope module srcbmux $end
$var wire 32 _# b [31:0] $end
$var wire 32 `# c [31:0] $end
$var wire 32 a# d [31:0] $end
$var wire 32 b# e [31:0] $end
$var wire 32 c# f [31:0] $end
$var wire 32 d# g [31:0] $end
$var wire 32 e# h [31:0] $end
$var wire 3 f# select [2:0] $end
$var wire 32 g# a [31:0] $end
$var reg 32 h# out [31:0] $end
$upscope $end
$scope module state_machine_a $end
$var wire 1 * clk $end
$var wire 1 J halt $end
$var wire 1 D jump $end
$var wire 4 i# prev_state [3:0] $end
$var wire 1 + reset $end
$var wire 1 ! wait_request $end
$var reg 1 ) active $end
$var reg 4 j# state [3:0] $end
$upscope $end
$scope module switch $end
$var wire 32 k# RegA [31:0] $end
$var wire 32 l# RegB [31:0] $end
$var wire 1 h switch $end
$var reg 32 m# aout [31:0] $end
$var reg 32 n# bout [31:0] $end
$upscope $end
$upscope $end
$scope module ramInst $end
$var wire 1 ) active $end
$var wire 32 o# address [31:0] $end
$var wire 4 p# byte_en [3:0] $end
$var wire 1 * clk $end
$var wire 32 q# data_in [31:0] $end
$var wire 1 & read_en $end
$var wire 1 # wr_en $end
$var wire 32 r# simp_address [31:0] $end
$var reg 32 s# data_out [31:0] $end
$scope begin $unm_blk_251 $end
$var integer 32 t# i [31:0] $end
$upscope $end
$scope begin $unm_blk_261 $end
$var integer 32 u# i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module mips_tb $end
$upscope $end
$enddefinitions $end
#5000
$dumpvars
b100000000000 u#
b100000000000 t#
bx s#
b0 r#
bx q#
bx p#
b0 o#
b0 n#
b0 m#
b0 l#
b0 k#
b1111 j#
bx i#
b100 h#
b0 g#
b1 f#
b0 e#
b0 d#
b0 c#
b0 b#
b0 a#
b0 `#
b100 _#
b0 ^#
b0 ]#
b0 \#
bx [#
b0 Z#
b0 Y#
b0 X#
b0 W#
b100 V#
b10111111110000000000000000000000 U#
b100 T#
b100 S#
b0 R#
b0 Q#
bx00 P#
bx O#
b100 N#
b0 M#
b0 L#
b100 K#
b0 J#
bx I#
b0xx H#
bx G#
bx F#
bx E#
bx D#
bx C#
b0 B#
b0 A#
0@#
bx00 ?#
bx >#
bx =#
b0 <#
b0 ;#
0:#
b0 9#
b0 8#
bx 7#
b0 6#
b0 5#
bx 4#
bx 3#
b0 2#
b1111 1#
b0 0#
b0 /#
b0 .#
x-#
x,#
x+#
x*#
x)#
x(#
x'#
x&#
x%#
x$#
x##
x"#
x!#
x~"
x}"
x|"
x{"
xz"
xy"
xx"
xw"
xv"
xu"
xt"
xs"
b0 r"
xq"
xp"
xo"
xn"
xm"
xl"
xk"
xj"
xi"
xh"
xg"
xf"
b0 e"
xd"
xc"
b0 b"
xa"
x`"
x_"
x^"
x]"
x\"
x["
xZ"
xY"
xX"
b0 W"
xV"
xU"
b0 T"
b0 S"
b0 R"
b0 Q"
b1 P"
b0 O"
b1111 N"
bx M"
bx L"
bx K"
b0 J"
b0 I"
b0 H"
b10111111110000000000000000000000 G"
b100 F"
b11111 E"
b1 D"
b1111 C"
b0 B"
bx A"
b1111 @"
b0 ?"
b0 >"
b0 ="
b1 <"
bx ;"
b0 :"
bx 9"
b100 8"
b1 7"
b0 6"
b100 5"
b0 4"
bx00 3"
bx00 2"
bx 1"
b0 0"
b0 /"
bx00 ."
b0 -"
b0 ,"
b0 +"
b0 *"
b0 )"
0("
0'"
b0 &"
bx %"
b0 $"
b0 #"
b0 ""
b0 !"
b11111 ~
b11111 }
b0 |
b0 {
bx z
bx y
b100 x
b0 w
b1 v
bx u
b0 t
b0 s
b0 r
b0 q
bx00 p
bx o
bx n
bx m
bx l
bx k
xj
bx i
0h
b0 g
b1 f
b0 e
b0 d
0c
0b
b0 a
b0 `
0_
b0 ^
b100 ]
bx \
b0 [
0Z
b0 Y
1X
bx00 W
b0 V
b0 U
b100 T
b0 S
b0 R
b1111 Q
b0 P
b1 O
b0 N
b0 M
bx L
b100 K
0J
bx I
0H
0G
0F
b0 E
0D
0C
0B
0A
0@
0?
bx >
b0 =
bx00 <
b100 ;
b0 :
b0 9
08
bx 7
b0 6
b0 5
b0 4
03
b0 2
b0 1
b1111 0
b10111111110000000000000000000000 /
b100 .
b11111 -
b1 ,
0+
1*
1)
b0 (
bx '
0&
bx %
b0 $
0#
bx "
z!
$end
