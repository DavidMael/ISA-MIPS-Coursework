$date
	Mon Dec  7 21:42:52 2020
$end
$version
	Icarus Verilog
$end
$timescale
	10ps
$end
$scope module mips_tb $end
$scope module cpuInst $end
$var wire 1 ! clk $end
$var wire 32 " constant_1 [31:0] $end
$var wire 32 # constant_31 [31:0] $end
$var wire 32 $ constant_4 [31:0] $end
$var wire 32 % constant_reset [31:0] $end
$var wire 1 & reset $end
$var wire 1 ' waitrequest $end
$var wire 1 ( write $end
$var wire 4 ) state [3:0] $end
$var wire 32 * signimm [31:0] $end
$var wire 32 + shiftimm [31:0] $end
$var wire 1 , reset_mux_cnt $end
$var wire 32 - register_v0 [31:0] $end
$var wire 32 . regbout [31:0] $end
$var wire 32 / regaout [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 1 read $end
$var wire 1 2 pc_write $end
$var wire 2 3 pc_src_mux [1:0] $end
$var wire 32 4 pc_out [31:0] $end
$var wire 32 5 pc_data [31:0] $end
$var wire 32 6 pc4_jump2 [31:0] $end
$var wire 3 7 msk_cnt [2:0] $end
$var wire 32 8 masked_data [31:0] $end
$var wire 1 9 lrmuxMSB $end
$var wire 1 : lr_en $end
$var wire 1 ; link_in $end
$var wire 1 < link_en $end
$var wire 1 = link $end
$var wire 1 > jump $end
$var wire 32 ? irout [31:0] $end
$var wire 1 @ ir_write $end
$var wire 1 A hilowrite $end
$var wire 1 B hilosel $end
$var wire 32 C hiloout [31:0] $end
$var wire 1 D halt $end
$var wire 32 E final_pc_data [31:0] $end
$var wire 32 F final_data [31:0] $end
$var wire 2 G extendcont [1:0] $end
$var wire 32 H constant_0 [31:0] $end
$var wire 2 I cond [1:0] $end
$var wire 2 J byte_cnt [1:0] $end
$var wire 4 K byte_EN [3:0] $end
$var wire 32 L bout [31:0] $end
$var wire 32 M aout [31:0] $end
$var wire 32 N aluresult [31:0] $end
$var wire 32 O aluout [31:0] $end
$var wire 4 P aluop [3:0] $end
$var wire 2 Q alu2out [1:0] $end
$var wire 32 R altpcsrc [31:0] $end
$var wire 1 S altpcmux_cnt $end
$var wire 32 T altpcdata [31:0] $end
$var wire 1 U alt_pc_write $end
$var wire 32 V address [31:0] $end
$var wire 1 W active $end
$var wire 32 X WriteRegData [31:0] $end
$var wire 32 Y SrcBOut [31:0] $end
$var wire 32 Z SrcAOut [31:0] $end
$var wire 1 [ RegWrite $end
$var wire 2 \ RegDst [1:0] $end
$var wire 2 ] MemToReg [1:0] $end
$var wire 1 ^ Jump_EN $end
$var wire 1 _ JumpIN $end
$var wire 2 ` IorD_cnt [1:0] $end
$var wire 5 a Dst [4:0] $end
$var wire 3 b ALUSrcB [2:0] $end
$var wire 2 c ALUSrcA [1:0] $end
$var wire 1 d ABswitch_cnt $end
$var reg 1 e branch $end
$var reg 4 f byteenable [3:0] $end
$var reg 2 g lrmuxLSB [1:0] $end
$var reg 4 h prev_state [3:0] $end
$var reg 32 i writedata [31:0] $end
$scope module IorD_mux $end
$var wire 32 j c [31:0] $end
$var wire 2 k select [1:0] $end
$var wire 32 l d [31:0] $end
$var wire 32 m b [31:0] $end
$var wire 32 n a [31:0] $end
$var reg 32 o out [31:0] $end
$upscope $end
$scope module MemToReg_mux $end
$var wire 32 p c [31:0] $end
$var wire 2 q select [1:0] $end
$var wire 32 r d [31:0] $end
$var wire 32 s b [31:0] $end
$var wire 32 t a [31:0] $end
$var reg 32 u out [31:0] $end
$upscope $end
$scope module RegDst_mux $end
$var wire 5 v a [4:0] $end
$var wire 5 w b [4:0] $end
$var wire 5 x c [4:0] $end
$var wire 5 y d [4:0] $end
$var wire 2 z select [1:0] $end
$var reg 5 { out [4:0] $end
$upscope $end
$scope module Registers $end
$var wire 1 ! clk $end
$var wire 5 | rr1 [4:0] $end
$var wire 5 } rr2 [4:0] $end
$var wire 1 & rst $end
$var wire 32 ~ wd [31:0] $end
$var wire 5 !" wr [4:0] $end
$var wire 1 [ wren $end
$var reg 1 "" a $end
$var reg 1 #" b $end
$var reg 32 $" r0 [31:0] $end
$var reg 1024 %" registers [1023:0] $end
$var reg 32 &" rs [31:0] $end
$var reg 32 '" rt [31:0] $end
$var reg 32 (" v0 [31:0] $end
$upscope $end
$scope module alt_pc $end
$var wire 1 ! clk $end
$var wire 1 & rst $end
$var wire 1 U wr_en $end
$var wire 32 )" p [31:0] $end
$var reg 32 *" q [31:0] $end
$var reg 32 +" single_reg [31:0] $end
$upscope $end
$scope module altpcmux $end
$var wire 1 S select $end
$var wire 32 ," b [31:0] $end
$var wire 32 -" a [31:0] $end
$var reg 32 ." out [31:0] $end
$upscope $end
$scope module alu $end
$var wire 4 /" ctrl [3:0] $end
$var wire 32 0" b [31:0] $end
$var wire 32 1" a [31:0] $end
$var reg 2 2" comp [1:0] $end
$var reg 32 3" out [31:0] $end
$upscope $end
$scope module alu2 $end
$var wire 1 ! clk $end
$var wire 2 4" p [1:0] $end
$var wire 1 & rst $end
$var reg 2 5" q [1:0] $end
$var reg 2 6" single_reg [1:0] $end
$upscope $end
$scope module alutstore $end
$var wire 1 ! clk $end
$var wire 32 7" p [31:0] $end
$var wire 1 & rst $end
$var reg 32 8" q [31:0] $end
$var reg 32 9" single_reg [31:0] $end
$upscope $end
$scope module brancher $end
$var wire 2 :" cond [1:0] $end
$var wire 6 ;" fn [5:0] $end
$var wire 5 <" info [4:0] $end
$var wire 6 =" opcode [5:0] $end
$var wire 4 >" state [3:0] $end
$var reg 1 _ JumpIN $end
$var reg 1 ^ Jump_EN $end
$upscope $end
$scope module byte_a $end
$var wire 2 ?" aluout [1:0] $end
$var wire 2 @" byte_cnt [1:0] $end
$var reg 4 A" byte_en [3:0] $end
$upscope $end
$scope module const_register $end
$var wire 32 B" const_1 [31:0] $end
$var wire 32 C" const_31 [31:0] $end
$var wire 32 D" const_4 [31:0] $end
$var wire 32 E" reset_vector [31:0] $end
$upscope $end
$scope module decoder_a $end
$var wire 1 e branch $end
$var wire 1 ! clk $end
$var wire 6 F" ir_function [5:0] $end
$var wire 5 G" ir_info [4:0] $end
$var wire 6 H" ir_opcode [5:0] $end
$var wire 6 I" mem_function [5:0] $end
$var wire 5 J" mem_info [4:0] $end
$var wire 6 K" mem_opcode [5:0] $end
$var wire 1 ' wait_request $end
$var wire 4 L" state [3:0] $end
$var wire 1 = link $end
$var reg 1 d ABswitch_cnt $end
$var reg 2 M" ALUSrcA [1:0] $end
$var reg 3 N" ALUSrcB [2:0] $end
$var reg 2 O" IorD [1:0] $end
$var reg 1 @ IrWrite $end
$var reg 1 1 MemRead $end
$var reg 2 P" MemToReg [1:0] $end
$var reg 1 ( MemWrite $end
$var reg 2 Q" PCSrc [1:0] $end
$var reg 1 2 PcWrite $end
$var reg 2 R" RegDst [1:0] $end
$var reg 1 [ RegWrite $end
$var reg 1 S" addiu $end
$var reg 1 T" addu $end
$var reg 1 U altpcWrite $end
$var reg 1 S altpcmux $end
$var reg 4 U" aluop [3:0] $end
$var reg 1 V" andINT $end
$var reg 1 W" andi $end
$var reg 1 X" beq $end
$var reg 1 Y" bgez $end
$var reg 1 Z" bgezal $end
$var reg 1 [" bgtz $end
$var reg 1 \" blez $end
$var reg 1 ]" bltz $end
$var reg 1 ^" bltzal $end
$var reg 1 _" bne $end
$var reg 2 `" byte_cnt [1:0] $end
$var reg 1 a" div $end
$var reg 1 b" divu $end
$var reg 2 c" extendcont [1:0] $end
$var reg 1 B hilosel $end
$var reg 1 A hilowrite $end
$var reg 1 d" j $end
$var reg 1 e" jal $end
$var reg 1 f" jalr $end
$var reg 1 g" jr $end
$var reg 1 h" lb $end
$var reg 1 i" lbu $end
$var reg 1 j" lh $end
$var reg 1 k" lhu $end
$var reg 1 < link_en $end
$var reg 1 ; link_in $end
$var reg 1 : lr_en $end
$var reg 1 9 lrmux $end
$var reg 1 l" lui $end
$var reg 1 m" lw $end
$var reg 1 n" lwl $end
$var reg 1 o" lwr $end
$var reg 3 p" mask_cnt [2:0] $end
$var reg 1 q" mfhi $end
$var reg 1 r" mflo $end
$var reg 1 s" mthi $end
$var reg 1 t" mtlo $end
$var reg 1 u" mult $end
$var reg 1 v" multu $end
$var reg 1 w" nop $end
$var reg 1 x" orINT $end
$var reg 1 y" ori $end
$var reg 1 , resetmux $end
$var reg 1 z" sb $end
$var reg 1 {" sh $end
$var reg 1 |" sll $end
$var reg 1 }" sllv $end
$var reg 1 ~" slt $end
$var reg 1 !# slti $end
$var reg 1 "# sltiu $end
$var reg 1 ## sltu $end
$var reg 1 $# sra $end
$var reg 1 %# srav $end
$var reg 1 &# srl $end
$var reg 1 '# srlv $end
$var reg 1 (# subu $end
$var reg 1 )# sw $end
$var reg 1 *# xorINT $end
$var reg 1 +# xori $end
$upscope $end
$scope module extender $end
$var wire 16 ,# in [15:0] $end
$var wire 2 -# select [1:0] $end
$var reg 32 .# out [31:0] $end
$upscope $end
$scope module halter_a $end
$var wire 1 ! clk $end
$var wire 1 & rst $end
$var wire 4 /# state [3:0] $end
$var wire 32 0# pcout [31:0] $end
$var reg 1 D halt $end
$upscope $end
$scope module hiloreg_a $end
$var wire 1 A WrEn $end
$var wire 1 ! clk $end
$var wire 1 B ctrl_hi $end
$var wire 32 1# input_hi_lo [31:0] $end
$var wire 1 & reset $end
$var reg 32 2# out [31:0] $end
$var reg 32 3# reg_hi [31:0] $end
$var reg 32 4# reg_lo [31:0] $end
$upscope $end
$scope module ir $end
$var wire 1 ! clk $end
$var wire 1 & rst $end
$var wire 1 @ wr_en $end
$var wire 32 5# p [31:0] $end
$var reg 32 6# q [31:0] $end
$var reg 32 7# single_reg [31:0] $end
$upscope $end
$scope module jump_reg $end
$var wire 1 ! clk $end
$var wire 1 _ p $end
$var wire 1 & rst $end
$var wire 1 ^ wr_en $end
$var reg 1 > q $end
$var reg 1 8# single_reg $end
$upscope $end
$scope module jumpshifter $end
$var wire 32 9# irout [31:0] $end
$var wire 32 :# pcout [31:0] $end
$var reg 4 ;# half1 [3:0] $end
$var reg 26 <# half2 [25:0] $end
$var reg 32 =# pc4jump2 [31:0] $end
$upscope $end
$scope module link_reg $end
$var wire 1 ! clk $end
$var wire 1 ; p $end
$var wire 1 & rst $end
$var wire 1 < wr_en $end
$var reg 1 = q $end
$var reg 1 ># single_reg $end
$upscope $end
$scope module loadword_mask $end
$var wire 3 ?# msk_cnt [2:0] $end
$var wire 2 @# msk_cnt2 [1:0] $end
$var wire 32 A# data [31:0] $end
$var reg 32 B# masked_data [31:0] $end
$var reg 32 C# temp1 [31:0] $end
$var reg 32 D# temp2 [31:0] $end
$upscope $end
$scope module lrblock_a $end
$var wire 32 E# final_data [31:0] $end
$var wire 1 : lr_en $end
$var wire 3 F# lrmux [2:0] $end
$var wire 32 G# masked_data [31:0] $end
$var wire 32 H# bout [31:0] $end
$upscope $end
$scope module pc $end
$var wire 1 ! clk $end
$var wire 1 & rst $end
$var wire 1 2 wr_en $end
$var wire 32 I# p [31:0] $end
$var reg 32 J# q [31:0] $end
$var reg 32 K# single_reg [31:0] $end
$upscope $end
$scope module pcsrc_mux $end
$var wire 32 L# a [31:0] $end
$var wire 32 M# b [31:0] $end
$var wire 32 N# c [31:0] $end
$var wire 32 O# d [31:0] $end
$var wire 2 P# select [1:0] $end
$var reg 32 Q# out [31:0] $end
$upscope $end
$scope module resetmux $end
$var wire 32 R# a [31:0] $end
$var wire 32 S# b [31:0] $end
$var wire 1 , select $end
$var reg 32 T# out [31:0] $end
$upscope $end
$scope module shifter2 $end
$var wire 32 U# in [31:0] $end
$var reg 32 V# out [31:0] $end
$upscope $end
$scope module srcamux $end
$var wire 32 W# a [31:0] $end
$var wire 32 X# c [31:0] $end
$var wire 32 Y# d [31:0] $end
$var wire 2 Z# select [1:0] $end
$var wire 32 [# b [31:0] $end
$var reg 32 \# out [31:0] $end
$upscope $end
$scope module srcbmux $end
$var wire 32 ]# b [31:0] $end
$var wire 32 ^# c [31:0] $end
$var wire 32 _# d [31:0] $end
$var wire 32 `# e [31:0] $end
$var wire 32 a# f [31:0] $end
$var wire 32 b# g [31:0] $end
$var wire 32 c# h [31:0] $end
$var wire 3 d# select [2:0] $end
$var wire 32 e# a [31:0] $end
$var reg 32 f# out [31:0] $end
$upscope $end
$scope module state_machine_a $end
$var wire 1 ! clk $end
$var wire 1 D halt $end
$var wire 1 > jump $end
$var wire 4 g# prev_state [3:0] $end
$var wire 1 & reset $end
$var wire 1 ' wait_request $end
$var reg 1 W active $end
$var reg 4 h# state [3:0] $end
$upscope $end
$scope module switch $end
$var wire 32 i# RegA [31:0] $end
$var wire 32 j# RegB [31:0] $end
$var wire 1 d switch $end
$var reg 32 k# aout [31:0] $end
$var reg 32 l# bout [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#43000
$dumpvars
bx l#
bx k#
bx j#
bx i#
b101 h#
bx g#
b100 f#
bx e#
b1 d#
b0 c#
b0 b#
b0xxxxx a#
b0xxxxx `#
b0xxxxxxxxxxxxxxxx00 _#
b0xxxxxxxxxxxxxxxx ^#
b100 ]#
b10111111110000000000000000000000 \#
bx [#
b0 Z#
b0 Y#
b0 X#
b10111111110000000000000000000000 W#
b0xxxxxxxxxxxxxxxx00 V#
b0xxxxxxxxxxxxxxxx U#
b10111111110000000000000000000100 T#
b10111111110000000000000000000000 S#
b10111111110000000000000000000100 R#
b10111111110000000000000000000100 Q#
b0 P#
b0 O#
bx00 N#
bx M#
b10111111110000000000000000000100 L#
b10111111110000000000000000000000 K#
b10111111110000000000000000000000 J#
b10111111110000000000000000000100 I#
bx H#
bx G#
b0xx F#
bx E#
bx D#
bx C#
bx B#
bx A#
b0 @#
b0 ?#
0>#
bx00 =#
bx <#
bx ;#
b10111111110000000000000000000000 :#
bx 9#
08#
bx 7#
bx 6#
bx 5#
b0 4#
b0 3#
b0 2#
bx 1#
b10111111110000000000000000000000 0#
b101 /#
b0xxxxxxxxxxxxxxxx .#
b0 -#
bx ,#
0+#
0*#
0)#
0(#
0'#
0&#
0%#
0$#
0##
0"#
0!#
0~"
0}"
1|"
0{"
0z"
0y"
0x"
0w"
0v"
0u"
0t"
0s"
0r"
0q"
b0 p"
0o"
0n"
0m"
0l"
0k"
0j"
0i"
0h"
0g"
0f"
0e"
0d"
b0 c"
0b"
0a"
b0 `"
0_"
0^"
0]"
0\"
0["
0Z"
0Y"
0X"
0W"
0V"
b0 U"
0T"
0S"
b0 R"
b0 Q"
b0 P"
b0 O"
b1 N"
b0 M"
b101 L"
bx K"
bx J"
bx I"
bx H"
bx G"
bx F"
b10111111110000000000000000000000 E"
b100 D"
b11111 C"
b1 B"
b1111 A"
b0 @"
bx ?"
b101 >"
bx ="
bx <"
bx ;"
b1 :"
bx 9"
bx 8"
b10111111110000000000000000000100 7"
bx 6"
b0 5"
bx 4"
b10111111110000000000000000000100 3"
b1 2"
b10111111110000000000000000000000 1"
b100 0"
b0 /"
bx00 ."
bx -"
bx00 ,"
b0 +"
b0 *"
bx00 )"
b0 ("
bx '"
bx &"
b0 %"
b0 $"
0#"
0""
bx !"
bx ~
bx }
bx |
bx {
b0 z
b11111 y
b11111 x
bx w
bx v
bx u
bx t
bx s
b10111111110000000000000000000100 r
b0 q
b1 p
b10111111110000000000000000000000 o
b10111111110000000000000000000000 n
bx m
b10111111110000000000000000000000 l
b0 k
bx00 j
bx i
bx h
bx g
bx f
xe
0d
b0 c
b1 b
bx a
b0 `
0_
0^
b0 ]
b0 \
0[
b10111111110000000000000000000000 Z
b100 Y
bx X
0W
b10111111110000000000000000000000 V
0U
b0 T
1S
bx00 R
b0 Q
b0 P
bx O
b10111111110000000000000000000100 N
bx M
bx L
b1111 K
b0 J
b1 I
b0 H
b0 G
bx F
b10111111110000000000000000000100 E
1D
b0 C
0B
0A
0@
bx ?
0>
0=
0<
0;
0:
09
bx 8
b0 7
bx00 6
b10111111110000000000000000000100 5
b10111111110000000000000000000000 4
b0 3
02
01
bx 0
bx /
bx .
b0 -
0,
b0xxxxxxxxxxxxxxxx00 +
b0xxxxxxxxxxxxxxxx *
b101 )
0(
z'
0&
b10111111110000000000000000000000 %
b100 $
b11111 #
b1 "
1!
$end
